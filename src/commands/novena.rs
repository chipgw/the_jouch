use crate::CommandResult;
use crate::{commands::birthday::parse_date, db::Db};
use anyhow::anyhow;
use chrono::{prelude::*, Duration, DurationRound};
use enum_utils::FromStr;
use serde::{Deserialize, Serialize};
use serenity::all::{
    ButtonStyle, ChannelId, CommandDataOptionValue, CommandInteraction, Context, CreateActionRow,
    CreateButton, CreateInteractionResponse, CreateInteractionResponseFollowup,
    CreateInteractionResponseMessage, CreateMessage, CreateSelectMenu, CreateSelectMenuKind,
    CreateSelectMenuOption, EditInteractionResponse, EditMessage, UserId,
};
use serenity::futures::StreamExt;
use sqlx::FromRow;
use tracing::{error, trace, warn};

#[derive(Eq, PartialEq, Debug, Serialize, Deserialize, Clone, Copy, FromStr, sqlx::Type)]
#[sqlx(type_name = "novena_mode")]
#[enumeration(case_insensitive)]
enum NovenaMode {
    DM,
    Channel,
}

#[derive(Eq, PartialEq, Debug, Serialize, Deserialize, Clone, FromRow)]
struct NovenaData {
    // unique identifier for the novena in the database, auto generated by postgres
    pub id: i64,
    pub mode: NovenaMode,
    // If mode == DM, the user to DM, if mode == Channel, the channel id
    pub destination: i64,
    pub title: String,
    pub start_time: DateTime<FixedOffset>,
    pub next_update: DateTime<FixedOffset>,
    pub novena_text: [String; 9],
}

impl NovenaData {
    pub async fn check(&self, ctx: &Context, db: &Db) -> anyhow::Result<()> {
        let day = (self.next_update - self.start_time).num_days();
        if day < 0 || day >= 9 {
            return Err(anyhow!(
                "calculated day out of range! calculated day: {}, start_time: {}, next_update: {}",
                day,
                self.start_time,
                self.next_update
            ));
        }

        let msg = format!(
            "{}, day {}:\n{}",
            self.title,
            day + 1,
            self.novena_text[day as usize]
        );

        match self.mode {
            NovenaMode::DM => {
                UserId::new(self.destination as u64)
                    .direct_message(ctx, CreateMessage::new().content(msg))
                    .await?;
            }
            NovenaMode::Channel => {
                ChannelId::new(self.destination as u64)
                    .say(&ctx.http, msg)
                    .await?;
            }
        }

        let result = if day == 8 {
            // novena over, remove it
            sqlx::query("DELETE FROM novenas WHERE id = $1")
                .bind(self.id)
                .execute(db.pool())
                .await?
        } else {
            // update the database with the next time the novena should send a message
            sqlx::query("UPDATE novenas SET next_update = $1 WHERE id = $2")
                .bind(self.next_update + Duration::days(1))
                .bind(self.id)
                .execute(db.pool())
                .await?
        };

        if result.rows_affected() != 1 {
            warn!(
                "Unexpected number of rows affected {} when updating novena {}",
                result.rows_affected(),
                self.id
            );
        }

        Ok(())
    }
}

async fn check_novenas(ctx: &Context) -> anyhow::Result<()> {
    let data = ctx.data.read().await;
    let db = data.get::<Db>().ok_or(anyhow!("Unable to get database"))?;

    // get any novenas in need of an update
    let novenas: Vec<NovenaData> =
        sqlx::query_as("SELECT * FROM novenas WHERE next_update <= NOW()")
            .fetch_all(db.pool())
            .await?;

    for novena in &novenas {
        if let Err(err) = novena.check(ctx, db).await {
            // Don't throw this so we can try any other novenas that may be in the update list
            error!("Error updating novena {}: {}", novena.id, err);
        }
    }

    Ok(())
}

const INTERVAL: Duration = Duration::hours(1);

// function to be spun off into its own thread to periodically check for novenas
pub async fn check_novenas_loop(ctx: Context) {
    loop {
        if let Err(err) = check_novenas(&ctx).await {
            error!("error checking novenas! {}", err);
        }

        // check hourly
        let next = Local::now() + INTERVAL;
        // try rounding to the hour, but don't bother if there's an error of some kind (there shouldn't be)
        let next = next.duration_round(INTERVAL).unwrap_or(next);

        // wait until next check
        tokio::time::sleep((next - Local::now()).to_std().unwrap()).await;
    }
}

async fn do_confirmed_delete(
    ctx: &Context,
    command: &CommandInteraction,
    db: &Db,
    id: i64,
    title: &str,
) -> anyhow::Result<()> {
    let mut msg = command
        .create_followup(
            &ctx,
            CreateInteractionResponseFollowup::new()
                .content(format!(
                    "Are you sure you want to delete {title}? This cannot be undone."
                ))
                .ephemeral(true)
                .components(vec![CreateActionRow::Buttons(vec![
                    CreateButton::new("delete_confirm")
                        .style(ButtonStyle::Danger)
                        .label("Delete"),
                    CreateButton::new("delete_cancel")
                        .style(ButtonStyle::Secondary)
                        .label("Cancel"),
                ])]),
        )
        .await?;

    if let Some(interaction) = msg.await_component_interaction(&ctx).await {
        let confirmed = interaction.data.custom_id == "delete_confirm";
        interaction
            .create_response(
                &ctx,
                CreateInteractionResponse::UpdateMessage(
                    CreateInteractionResponseMessage::new()
                        .content(if confirmed {
                            "Proccessing..."
                        } else {
                            "Canceled."
                        })
                        .components(vec![]),
                ),
            )
            .await?;

        if !confirmed {
            return Ok(());
        }

        let result = sqlx::query("DELETE FROM novenas WHERE id = $1")
            .bind(id)
            .execute(db.pool())
            .await?;

        if result.rows_affected() != 1 {
            Err(anyhow!(
                "Unexpected number of rows affected {} when deleting novena {}",
                result.rows_affected(),
                id
            ))
        } else {
            msg.edit(
                &ctx,
                EditMessage::new().content(format!("Deleted {title}.")),
            )
            .await?;
            Ok(())
        }
    } else {
        Err(anyhow!("Unable to get interaction response"))
    }
}

async fn do_selected_delete(
    ctx: &Context,
    command: &CommandInteraction,
    db: &Db,
    novenas: &Vec<NovenaData>,
) -> anyhow::Result<()> {
    let mut msg = command
        .create_followup(
            &ctx,
            CreateInteractionResponseFollowup::new()
                .content("Which novena(s) would you like to delete?")
                .ephemeral(true)
                .components(vec![
                    CreateActionRow::SelectMenu(
                        CreateSelectMenu::new(
                            "novena_selection",
                            CreateSelectMenuKind::String {
                                options: novenas
                                    .iter()
                                    .map(|novena| {
                                        CreateSelectMenuOption::new(
                                            novena.title.clone(),
                                            novena.id.to_string(),
                                        )
                                    })
                                    .collect(),
                            },
                        )
                        .min_values(0)
                        .max_values(novenas.len() as u8),
                    ),
                    CreateActionRow::Buttons(vec![
                        CreateButton::new("delete_confirm")
                            .style(ButtonStyle::Danger)
                            .label("Delete"),
                        CreateButton::new("delete_cancel")
                            .style(ButtonStyle::Secondary)
                            .label("Cancel"),
                    ]),
                ]),
        )
        .await?;

    let mut collector = msg.await_component_interaction(&ctx).stream();

    let mut selection: Vec<String> = Vec::new();

    while let Some(interaction) = collector.next().await {
        match &interaction.data.kind {
            serenity::all::ComponentInteractionDataKind::Button => {
                let confirmed =
                    interaction.data.custom_id == "delete_confirm" && !selection.is_empty();
                interaction
                    .create_response(
                        &ctx,
                        CreateInteractionResponse::UpdateMessage(
                            CreateInteractionResponseMessage::new()
                                .content(if confirmed {
                                    "Proccessing..."
                                } else {
                                    "Canceled."
                                })
                                .components(vec![]),
                        ),
                    )
                    .await?;

                if !confirmed {
                    return Ok(());
                }

                let result = sqlx::query(&format!(
                    "DELETE FROM novenas WHERE id IN ({})",
                    selection.join(", ")
                ))
                .execute(db.pool())
                .await?;

                return if result.rows_affected() as usize != selection.len() {
                    Err(anyhow!(
                        "Unexpected number of rows affected {} when deleting novena(s) {:?}",
                        result.rows_affected(),
                        selection
                    ))
                } else {
                    msg.edit(
                        &ctx,
                        EditMessage::new()
                            .content(format!("Deleted {} novena(s).", selection.len())),
                    )
                    .await?;
                    Ok(())
                };
            }
            serenity::all::ComponentInteractionDataKind::StringSelect { values } => {
                interaction
                    .create_response(&ctx, CreateInteractionResponse::Acknowledge)
                    .await?;
                selection = values.clone();
                trace!("selected novenas: {:?}", values);
            }
            _ => {}
        }
    }
    Err(anyhow!("Unable to get interaction response"))
}

pub async fn novena(ctx: &Context, command: &CommandInteraction) -> CommandResult {
    let subcommand = command
        .data
        .options
        .get(0)
        .ok_or(anyhow!("Please provide a valid subcommand"))?;

    let (mode, destination) = if command.guild_id.is_some() {
        // TODO - do we need to double check permissions or is the setting on the command enough to handle it?
        (NovenaMode::Channel, command.channel_id.get() as i64)
    } else {
        (NovenaMode::DM, command.user.id.get() as i64)
    };

    let data = ctx.data.read().await;
    let db = data.get::<Db>().ok_or(anyhow!("Unable to get database"))?;

    match subcommand.name.as_str() {
        "unique" | "repeated" => {
            if let CommandDataOptionValue::SubCommand(subcommand_args) = &subcommand.value {
                let mut title = String::new();
                let mut start = Local::now().fixed_offset() + INTERVAL;
                let mut text: [String; 9] = Default::default();

                for arg in subcommand_args {
                    if let CommandDataOptionValue::String(arg_str) = &arg.value {
                        match arg.name.as_str() {
                            "title" => title.clone_from(arg_str),
                            "prayer" => {
                                for day in &mut text {
                                    day.clone_from(arg_str);
                                }
                            }
                            "start" => {
                                start = parse_date(&arg_str, Some(start.time()), Some(start))?;
                                if start < Local::now().fixed_offset() {
                                    return Err(anyhow!("Novena start date is in the past!"));
                                }
                            }
                            // TODO - improve error message
                            _ if arg.name.starts_with("day") => text[arg
                                .name
                                .chars()
                                .last()
                                .unwrap()
                                .to_digit(10)
                                .ok_or(anyhow!("unable to parse int from day argument name"))?
                                as usize]
                                .clone_from(arg_str),
                            _ => warn!("unknown argument passed!"),
                        }
                    }
                }

                // Round to the interval if we can
                start = start.duration_round(INTERVAL).unwrap_or(start);

                sqlx::query(
                    "INSERT INTO novenas (destination, mode, title, start_time, next_update, novena_text)
                        VALUES ($1, $2, $3, $4, $5, $6)").bind(destination).bind(mode).bind(&title).bind(&start).bind(&start).bind(text).execute(db.pool()).await?;

                command
                    .edit_response(
                        &ctx,
                        EditInteractionResponse::new()
                            .content(format!("Novena {title} scheduled to start {start}")),
                    )
                    .await?;

                Ok(())
            } else {
                Err(anyhow!("No arguments passed"))
            }
        }
        "stop" => {
            let novenas: Vec<NovenaData> =
                sqlx::query_as("SELECT * FROM novenas WHERE destination = $1")
                    .bind(destination)
                    .fetch_all(db.pool())
                    .await?;

            match novenas.len() {
                0 => {
                    // TODO - when destination is channel, clarify that it has to be sent in the same channel the novena is running in
                    Err(anyhow!("No novenas found to stop"))
                }
                1 => {
                    // only one novena found, confirm and delete
                    do_confirmed_delete(ctx, command, db, novenas[0].id, &novenas[0].title).await
                }
                _ => {
                    // more than one novena found, let the user choose which to delete
                    do_selected_delete(ctx, command, db, &novenas).await
                }
            }
        }
        _ => Err(anyhow!("Unknown option {}", subcommand.name).into()),
    }
}
